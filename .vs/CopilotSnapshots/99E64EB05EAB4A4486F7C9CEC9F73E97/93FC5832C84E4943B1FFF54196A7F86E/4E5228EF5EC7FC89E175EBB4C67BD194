using EFDemo.Domain;
using EFDemo.Domain.Repositories;
using EFDemo.Domain.Specifications;
using EFDemo.Infrastructure.Data;

namespace EFDemo.Infrastructure.Repositories
{
    /// <summary>
    /// Specific repository implementation for Customer entities.
    /// 
    /// LEARNING NOTE: This class inherits from the generic Repository<Customer>
    /// to get all the basic CRUD operations, then adds Customer-specific methods.
    /// This is a great example of the Open/Closed Principle - the base class
    /// is closed for modification but open for extension.
    /// </summary>
    public class CustomerRepository : Repository<Customer>, ICustomerRepository
    {
        /// <summary>
        /// Constructor that passes the context to the base repository.
        /// LEARNING NOTE: The base constructor handles setting up the generic
        /// repository functionality, so we just need to pass along the context.
        /// </summary>
        /// <param name="context">The Entity Framework context</param>
        public CustomerRepository(CustomerContext context) : base(context)
        {
        }

        /// <summary>
        /// Gets all active customers.
        /// LEARNING NOTE: This method uses the ActiveCustomersSpecification
        /// we created earlier. Notice how we delegate to the specification
        /// rather than writing the query logic here. This keeps the repository
        /// focused on data access while the specification handles business rules.
        /// </summary>
        public async Task<IReadOnlyList<Customer>> GetActiveCustomersAsync()
        {
            var spec = new ActiveCustomersSpecification();
            return await ListAsync(spec);
        }

        /// <summary>
        /// Searches for customers by name.
        /// </summary>
        public async Task<IReadOnlyList<Customer>> SearchByNameAsync(string searchTerm)
        {
            var spec = new CustomersByNameSpecification(searchTerm);
            return await ListAsync(spec);
        }

        /// <summary>
        /// Gets customers with pagination.
        /// </summary>
        public async Task<IReadOnlyList<Customer>> GetCustomersPagedAsync(int pageNumber, int pageSize, bool activeOnly = true)
        {
            var spec = new CustomersWithPagingSpecification(pageNumber, pageSize, activeOnly);
            return await ListAsync(spec);
        }

        /// <summary>
        /// Gets the total count of customers.
        /// </summary>
        public async Task<int> GetCustomerCountAsync(bool activeOnly = true)
        {
            if (activeOnly)
            {
                var spec = new ActiveCustomersSpecification();
                return await CountAsync(spec);
            }
            else
            {
                // LEARNING NOTE: For counting all customers, we don't need a specification
                // We can use the generic repository's CountAsync with a simple specification
                var spec = new BaseSpecification<Customer>();
                return await CountAsync(spec);
            }
        }

        /// <summary>
        /// Checks if a customer with the given name already exists.
        /// LEARNING NOTE: This is a good example of a domain-specific query
        /// that doesn't fit well into the generic specification pattern.
        /// It's perfectly fine to have some repository methods that use
        /// Entity Framework directly for complex or specific queries.
        /// </summary>
        public async Task<bool> CustomerExistsAsync(string firstName, string lastName, int? excludeId = null)
        {
            var query = _context.Customers
                .Where(c => c.FirstName.ToLower() == firstName.ToLower() && 
                           c.LastName.ToLower() == lastName.ToLower());

            // If we're updating an existing customer, exclude their current record
            if (excludeId.HasValue)
            {
                query = query.Where(c => c.Id != excludeId.Value);
            }

            return await query.AnyAsync();
        }
    }
}