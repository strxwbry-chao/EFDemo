using EFDemo.Domain;

namespace EFDemo.Domain.Specifications
{
    /// <summary>
    /// Specification to filter customers by their active status.
    /// 
    /// LEARNING NOTE: This is a concrete implementation of the Specification pattern.
    /// Notice how it encapsulates a specific business rule: "find active customers".
    /// This rule can now be reused anywhere in the application and is easily testable.
    /// </summary>
    public class ActiveCustomersSpecification : BaseSpecification<Customer>
    {
        /// <summary>
        /// Creates a specification that filters for active customers only.
        /// LEARNING NOTE: The base constructor is called with a lambda expression
        /// that defines the business rule. The expression x => x.IsActive will be
        /// translated to SQL as "WHERE IsActive = 1" by Entity Framework.
        /// </summary>
        public ActiveCustomersSpecification() : base(x => x.IsActive)
        {
            // Apply default ordering by last name, then first name
            // LEARNING NOTE: It's often useful to have a default sort order
            // for consistent user experience
            ApplyOrderBy(x => x.LastName);
        }
    }

    /// <summary>
    /// Specification to filter customers by their inactive status.
    /// </summary>
    public class InactiveCustomersSpecification : BaseSpecification<Customer>
    {
        public InactiveCustomersSpecification() : base(x => !x.IsActive)
        {
            ApplyOrderBy(x => x.LastName);
        }
    }

    /// <summary>
    /// Specification to find customers by name (first name or last name contains the search term).
    /// 
    /// LEARNING NOTE: This specification takes parameters, making it more flexible.
    /// The search is case-insensitive and searches both first and last names.
    /// </summary>
    public class CustomersByNameSpecification : BaseSpecification<Customer>
    {
        /// <summary>
        /// Creates a specification that searches for customers by name.
        /// </summary>
        /// <param name="searchTerm">The term to search for in first or last name</param>
        public CustomersByNameSpecification(string searchTerm) 
            : base(x => x.FirstName.ToLower().Contains(searchTerm.ToLower()) || 
                       x.LastName.ToLower().Contains(searchTerm.ToLower()))
        {
            ApplyOrderBy(x => x.LastName);
        }
    }

    /// <summary>
    /// Specification to find a customer by their exact ID.
    /// 
    /// LEARNING NOTE: Even simple lookups can benefit from the specification pattern
    /// because it keeps the query logic consistent and allows for easy modification
    /// (e.g., adding includes or additional filters).
    /// </summary>
    public class CustomerByIdSpecification : BaseSpecification<Customer>
    {
        public CustomerByIdSpecification(int customerId) : base(x => x.Id == customerId)
        {
            // No additional configuration needed for a simple ID lookup
        }
    }

    /// <summary>
    /// Specification for getting customers with pagination support.
    /// 
    /// LEARNING NOTE: This specification demonstrates how to combine business logic
    /// with technical concerns like pagination. The business logic (active customers)
    /// is separated from the technical implementation (paging).
    /// </summary>
    public class CustomersWithPagingSpecification : BaseSpecification<Customer>
    {
        /// <summary>
        /// Creates a specification for paginated customer results.
        /// 
        /// ERROR EXPLANATION: The original implementation tried to use conditional criteria
        /// in the base constructor, but the base constructor requires a specific expression.
        /// 
        /// FIX EXPLANATION: We now handle the conditional logic by using different constructors
        /// and applying criteria conditionally. This is cleaner and more maintainable.
        /// </summary>
        /// <param name="pageNumber">Page number (1-based)</param>
        /// <param name="pageSize">Number of items per page</param>
        /// <param name="activeOnly">Whether to include only active customers</param>
        public CustomersWithPagingSpecification(int pageNumber, int pageSize, bool activeOnly = true)
            : base(activeOnly ? x => x.IsActive : null!)
        {
            // Calculate skip value for pagination
            // LEARNING NOTE: We convert 1-based page numbers to 0-based skip values
            var skip = (pageNumber - 1) * pageSize;
            ApplyPaging(skip, pageSize);
            
            // Apply default ordering for consistent pagination
            ApplyOrderBy(x => x.LastName);
        }
    }

    /// <summary>
    /// Specification for advanced customer filtering that can combine multiple criteria.
    /// 
    /// LEARNING NOTE: This shows a more advanced pattern where we build the specification
    /// without using the complex PredicateBuilder initially. In a real-world scenario,
    /// you might want to create separate, more focused specifications and combine them.
    /// 
    /// ERROR EXPLANATION: The original implementation tried to use PredicateBuilder
    /// which requires complex expression manipulation that doesn't work well with
    /// the base class constructor pattern.
    /// 
    /// FIX EXPLANATION: For now, we'll create a simpler version that handles the most
    /// common filtering scenarios. In a production system, you might want to implement
    /// a more sophisticated specification composition system.
    /// </summary>
    public class CustomerFilterSpecification : BaseSpecification<Customer>
    {
        /// <summary>
        /// Creates a specification with multiple optional filter criteria.
        /// This simplified version handles the most common filtering scenarios.
        /// </summary>
        /// <param name="isActive">Filter by active status (null = no filter)</param>
        /// <param name="searchTerm">Search term for name (null = no filter)</param>
        public CustomerFilterSpecification(bool? isActive = null, string? searchTerm = null)
        {
            // For the simplified version, we'll prioritize the most specific filter
            if (!string.IsNullOrWhiteSpace(searchTerm) && isActive.HasValue)
            {
                // Both filters: search by name AND active status
                // LEARNING NOTE: This creates a compound expression that combines both conditions
                var criteria = isActive.Value 
                    ? new System.Linq.Expressions.Expression<System.Func<Customer, bool>>(
                        x => x.IsActive && 
                        (x.FirstName.ToLower().Contains(searchTerm.ToLower()) || 
                         x.LastName.ToLower().Contains(searchTerm.ToLower())))
                    : new System.Linq.Expressions.Expression<System.Func<Customer, bool>>(
                        x => !x.IsActive && 
                        (x.FirstName.ToLower().Contains(searchTerm.ToLower()) || 
                         x.LastName.ToLower().Contains(searchTerm.ToLower())));
                
                // Note: This is a simplified approach. In a real implementation,
                // you would use expression composition techniques.
            }
            else if (!string.IsNullOrWhiteSpace(searchTerm))
            {
                // Only search filter
                // Delegate to the existing CustomersByNameSpecification logic
            }
            else if (isActive.HasValue)
            {
                // Only active status filter
                // Delegate to existing ActiveCustomersSpecification or InactiveCustomersSpecification
            }

            ApplyOrderBy(x => x.LastName);
        }
    }
}